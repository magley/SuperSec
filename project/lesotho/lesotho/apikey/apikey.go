package apikey

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/google/uuid"
	"github.com/syndtr/goleveldb/leveldb"
	"golang.org/x/crypto/bcrypt"
)

type APIKeyRepository struct {
	// Data is stored in the following schema:
	//	- Key is the client name (e.g. 'Docs', 'videotube.com' etc.)
	//  - Value is the API key HASHED by bcrypt
	db *leveldb.DB
}

func OpenAPIKeyRepository(fname string) *APIKeyRepository {
	apiKeyRepo := new(APIKeyRepository)
	db, err := leveldb.OpenFile(fname, nil)
	if err != nil {
		panic(err)
	}
	apiKeyRepo.db = db
	return apiKeyRepo
}

func (apiKeyRepo *APIKeyRepository) Close() {
	if apiKeyRepo.db != nil {
		apiKeyRepo.db.Close()
	}
}

// IssueAPIKey assigns an new API key for the provided client name. Old API will
// get overwritten. Client name must not be an empty string.
func (apiKeyRepo *APIKeyRepository) IssueAPIKey(client string) (string, error) {
	id := uuid.New()
	apiKey := id.String()

	if len(client) == 0 {
		return "", fmt.Errorf("client name must not be an empty string")
	}

	hashedAPIKey, err := bcrypt.GenerateFromPassword([]byte(apiKey), 0)
	if err != nil {
		return "", err
	}

	err = apiKeyRepo.db.Put([]byte(client), []byte(hashedAPIKey), nil)
	if err != nil {
		return "", err
	}

	return apiKey, nil
}

// CheckAPIKeyRaw does a lookup in the api key database and returns true if the
// api key is found, false otherwise.
//
// You probably want CheckAPIKey() when calling from the controller.
func (apiKeyRepo *APIKeyRepository) CheckAPIKeyRaw(client string, rawKey string) bool {
	hashedApiKey, err := apiKeyRepo.db.Get([]byte(client), nil)
	if err != nil {
		return false
	}
	err = bcrypt.CompareHashAndPassword(hashedApiKey, []byte(rawKey))
	return err == nil
}

// CheckAPIKey does a lookup in the api key database and returns true if the api
// key is found, false otherwise.
//
// The request must have the following header set:
//
//	Authorization: [client name] [api key]
func (apiKeyRepo *APIKeyRepository) CheckAPIKey(request *http.Request) bool {
	const SEP = " "
	// Must have the following format:
	// client apikey
	// client can be any string, even with `SEP``
	// apikey is the raw api key generated by lesotho
	// the last `SEP` separates client from apikey
	authorization := request.Header.Get("Authorization")

	parts := strings.Split(authorization, SEP)
	if len(parts) < 2 {
		return false
	}

	client := strings.Join(parts[:len(parts)-1], SEP)
	rawKey := parts[len(parts)-1]

	return apiKeyRepo.CheckAPIKeyRaw(client, rawKey)
}

// RevokeAPIKey removes the API key for the given client. RevokeAPIKey does not
// return an error if the client does not have an API key.
func (apiKeyRepo *APIKeyRepository) RevokeAPIKey(client string) error {
	err := apiKeyRepo.db.Delete([]byte(client), nil)
	return err
}
